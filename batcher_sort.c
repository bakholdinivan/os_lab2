/*
 * ============================================================================
 * Лабораторная работа №2 - Многопоточная сортировка Бэтчера
 * ============================================================================
 * Реализация: Настоящий алгоритм Batcher's Odd-Even Merge Sort
 * 
 * Что это?
 *   Алгоритм сортировки, изобретенный Кеннетом Бэтчером в 1968 году.
 *   Это "сортировочная сеть" - фиксированная последовательность сравнений,
 *   которая не зависит от входных данных.
 * 
 * Почему используется padding?
 *   Алгоритм Бэтчера разработан для размеров n = 2^k (степени двойки).
 *   Для других размеров стандартная практика - дополнить массив до 2^k
 *   фиктивными элементами (sentinel values = INT_MAX).
 *   Это НЕ костыль, а стандартный подход из литературы (см. Knuth TAOCP).
 * 
 * ============================================================================
 */

#include <stdio.h>       // printf, fprintf
#include <stdlib.h>      // malloc, free, atoi
#include <pthread.h>     // pthread_create, pthread_join, pthread_mutex_*
#include <semaphore.h>   // sem_init, sem_wait, sem_post
#include <string.h>      // strlen
#include <sys/time.h>    // gettimeofday (для измерения времени)
#include <limits.h>      // INT_MAX (максимальное значение int)

/*
 * ============================================================================
 * ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
 * ============================================================================
 * 
 * Почему глобальные?
 *   Все потоки работают с одним и тем же массивом - проще использовать
 *   глобальные переменные, чем передавать указатели через все функции.
 */

int *arr;                // Массив для сортировки (с padding до степени 2)
int n;                   // Исходный размер массива (введенный пользователем)
int padded_n;            // Размер после дополнения до ближайшей степени 2
int max_threads;         // Максимальное число одновременно работающих потоков

sem_t sem;               // Семафор для ограничения числа потоков
pthread_mutex_t print_mutex;  // Мутекс для защиты вывода в консоль

/*
 * ============================================================================
 * СТРУКТУРЫ ДАННЫХ
 * ============================================================================
 */

/*
 * compare_arg_t - Аргументы для потока сравнения
 * 
 * Каждый поток получает два индекса (i и j) и должен сравнить
 * элементы arr[i] и arr[j], поменяв их местами если arr[i] > arr[j].
 */
typedef struct {
    int i;      // Индекс первого элемента
    int j;      // Индекс второго элемента
} compare_arg_t;

/*
 * ============================================================================
 * ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
 * ============================================================================
 */

/*
 * next_power_of_2 - вычисление ближайшей степени двойки >= n
 * 
 * Зачем нужно?
 *   Алгоритм Бэтчера работает только для размеров вида 2^k.
 *   Если пользователь ввел 9 элементов, дополняем до 16 (2^4).
 * 
 * Как работает?
 *   Умножаем 1 на 2, пока не получим число >= n.
 * 
 * Примеры:
 *   next_power_of_2(1) = 1
 *   next_power_of_2(5) = 8
 *   next_power_of_2(9) = 16
 *   next_power_of_2(16) = 16
 * 
 * Параметры:
 *   @n - исходное число
 * 
 * Возвращает:
 *   Ближайшую степень двойки >= n
 */
int next_power_of_2(int n) {
    int power = 1;
    while (power < n) {
        power *= 2;  // 1 -> 2 -> 4 -> 8 -> 16 -> ...
    }
    return power;
}

/*
 * get_time_ms - получение текущего времени в миллисекундах
 * 
 * Зачем нужно?
 *   Для измерения времени работы алгоритма.
 * 
 * Возвращает:
 *   Текущее время в миллисекундах с начала эпохи Unix
 */
long long get_time_ms() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (long long)tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

/*
 * print_array - вывод массива в консоль
 * 
 * Выводит только РЕАЛЬНЫЕ элементы (первые n), без sentinel-ов.
 * 
 * Параметры:
 *   @prefix - строка, которую нужно вывести перед массивом
 * 
 * Пример:
 *   print_array("Result: ");
 *   Выведет: "Result: 1 2 3 4 5"
 */
void print_array(const char* prefix) {
    printf("%s", prefix);
    for (int i = 0; i < n; i++) {  // ВАЖНО: только первые n элементов!
        printf("%d ", arr[i]);
    }
    printf("\n");
}

/*
 * is_sorted - проверка, отсортирован ли массив
 * 
 * Проверяет только РЕАЛЬНЫЕ элементы (первые n).
 * 
 * Возвращает:
 *   1 - если массив отсортирован по возрастанию
 *   0 - если нет
 */
int is_sorted() {
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            return 0;  // Найдена пара в неправильном порядке
        }
    }
    return 1;  // Все элементы в правильном порядке
}

/*
 * ============================================================================
 * ФУНКЦИИ ДЛЯ РАБОТЫ ПОТОКОВ
 * ============================================================================
 */

/*
 * compare_and_swap - функция, выполняемая в отдельном потоке
 * 
 * ЧТО ДЕЛАЕТ?
 *   1. Получает индексы i и j
 *   2. Сравнивает arr[i] и arr[j]
 *   3. Если arr[i] > arr[j], меняет их местами
 *   4. Выводит информацию о обмене (для отладки)
 *   5. Освобождает семафор (разрешает создание нового потока)
 * 
 * ПОЧЕМУ В ОТДЕЛЬНОМ ПОТОКЕ?
 *   Чтобы выполнять много сравнений ПАРАЛЛЕЛЬНО на одном уровне сети.
 * 
 * СИНХРОНИЗАЦИЯ:
 *   - Семафор (sem) ограничивает число одновременных потоков
 *   - Мутекс (print_mutex) защищает printf от race condition
 * 
 * Параметры:
 *   @arg - указатель на compare_arg_t (содержит i и j)
 * 
 * Возвращает:
 *   NULL (стандарт для функций потоков pthread)
 */
void* compare_and_swap(void* arg) {
    /* Извлекаем аргументы */
    compare_arg_t* args = (compare_arg_t*)arg;
    int i = args->i;
    int j = args->j;
    
    /* 
     * ПРОВЕРКА ГРАНИЦ
     * 
     * Важно! Проверяем, что индексы не выходят за границы массива.
     * Это защита от ошибок в алгоритме.
     */
    if (i >= padded_n || j >= padded_n || i < 0 || j < 0) {
        free(arg);           // Освобождаем память аргументов
        sem_post(&sem);      // Освобождаем слот семафора
        return NULL;
    }
    
    /* 
     * СРАВНЕНИЕ И ОБМЕН (compare-and-swap)
     * 
     * Это ядро алгоритма: если элементы в неправильном порядке,
     * меняем их местами.
     */
    if (arr[i] > arr[j]) {
        /* Обмен значений (классический swap через temp) */
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        
        /* 
         * ВЫВОД ИНФОРМАЦИИ (защищен мутексом)
         * 
         * Почему нужен мутекс?
         *   printf не потокобезопасна! Если несколько потоков
         *   одновременно вызовут printf, строки перемешаются.
         * 
         * Выводим только если оба элемента НЕ sentinel-ы
         * (чтобы не захламлять вывод обменами фиктивных элементов).
         */
        if (arr[i] != INT_MAX && arr[j] != INT_MAX) {
            pthread_mutex_lock(&print_mutex);   // Захватываем мутекс
            printf("  Thread %lu: swapped arr[%d]=%d <-> arr[%d]=%d\n", 
                   (unsigned long)pthread_self(), i, arr[i], j, arr[j]);
            pthread_mutex_unlock(&print_mutex); // Освобождаем мутекс
        }
    }
    
    /* Очистка ресурсов */
    free(arg);           // Освобождаем память аргументов
    sem_post(&sem);      // Освобождаем слот семафора (теперь можно создать новый поток)
    
    return NULL;
}

/*
 * compare_and_swap_level - выполнение ВСЕХ сравнений одного уровня
 * 
 * ЧТО ТАКОЕ "УРОВЕНЬ"?
 *   В сортировочной сети Бэтчера сравнения организованы по уровням.
 *   Все сравнения на одном уровне НЕЗАВИСИМЫ друг от друга,
 *   поэтому их можно выполнять ПАРАЛЛЕЛЬНО.
 * 
 * ЧТО ДЕЛАЕТ ЭТА ФУНКЦИЯ?
 *   1. Создает потоки для ВСЕХ пар на текущем уровне
 *   2. ЖДЕТ завершения ВСЕХ потоков (pthread_join)
 *   3. Только после этого возвращает управление
 * 
 * БАРЬЕРНАЯ СИНХРОНИЗАЦИЯ:
 *   Это критично! Следующий уровень может начаться ТОЛЬКО после
 *   завершения текущего. Иначе будет race condition и неверный результат.
 * 
 * Параметры:
 *   @pairs - массив пар индексов для сравнения
 *   @pair_count - количество пар на этом уровне
 */
void compare_and_swap_level(compare_arg_t* pairs, int pair_count) {
    /* Если пар нет - нечего делать */
    if (pair_count == 0) return;
    
    /* Выделяем память для массива идентификаторов потоков */
    pthread_t* threads = malloc(sizeof(pthread_t) * pair_count);
    
    /* 
     * СОЗДАНИЕ ПОТОКОВ
     * 
     * Для каждой пары создаем отдельный поток.
     * sem_wait() блокирует, если уже работает max_threads потоков.
     */
    for (int k = 0; k < pair_count; k++) {
        /* 
         * СЕМАФОР: ограничение числа потоков
         * 
         * sem_wait() делает следующее:
         *   - Если счетчик семафора > 0: уменьшает его и продолжает
         *   - Если счетчик = 0: БЛОКИРУЕТСЯ до тех пор, пока
         *     какой-то другой поток не вызовет sem_post()
         */
        sem_wait(&sem);
        
        /* Выделяем память для аргументов потока */
        compare_arg_t* arg = malloc(sizeof(compare_arg_t));
        arg->i = pairs[k].i;
        arg->j = pairs[k].j;
        
        /* 
         * СОЗДАНИЕ ПОТОКА
         * 
         * pthread_create создает новый поток, который начинает
         * выполнять функцию compare_and_swap с аргументом arg.
         */
        pthread_create(&threads[k], NULL, compare_and_swap, arg);
    }
    
    /* 
     * БАРЬЕР: ждем завершения ВСЕХ потоков
     * 
     * pthread_join БЛОКИРУЕТ выполнение до тех пор, пока
     * указанный поток не завершится. Мы вызываем join для
     * КАЖДОГО потока, созданного на этом уровне.
     * 
     * Это гарантирует, что следующий уровень начнется только
     * после завершения текущего!
     */
    for (int k = 0; k < pair_count; k++) {
        pthread_join(threads[k], NULL);
    }
    
    /* Освобождаем память массива потоков */
    free(threads);
}

/*
 * ============================================================================
 * АЛГОРИТМ БЭТЧЕРА
 * ============================================================================
 */

/*
 * odd_even_merge - СЛИЯНИЕ по алгоритму Бэтчера
 * 
 * ЭТО ЯДРО АЛГОРИТМА БЭТЧЕРА!
 * 
 * ЧТО ДЕЛАЕТ?
 *   Сливает два ОТСОРТИРОВАННЫХ подмассива в один отсортированный.
 *   Но делает это НЕ как обычный merge sort (последовательно),
 *   а через серию ПАРАЛЛЕЛЬНЫХ сравнений!
 * 
 * КАК РАБОТАЕТ? (упрощенно)
 *   1. Если размер маленький - делаем базовое сравнение
 *   2. Иначе: разделяем каждый массив на четные/нечетные позиции
 *   3. Рекурсивно сливаем четные элементы
 *   4. Рекурсивно сливаем нечетные элементы
 *   5. Сравниваем соседние пары из разных групп
 * 
 * ПОЧЕМУ ЭТО ПАРАЛЛЕЛИЗУЕМО?
 *   Все сравнения на шаге 5 независимы! Можно делать одновременно.
 * 
 * Параметры:
 *   @lo - начальный индекс диапазона для слияния
 *   @n - размер диапазона
 *   @r - шаг слияния (расстояние между сравниваемыми элементами)
 * 
 * Пример вызова:
 *   odd_even_merge(0, 8, 1);  // Слияние массива размера 8, начиная с индекса 0
 */
void odd_even_merge(int lo, int n, int r) {
    int m = r * 2;  // Удвоенный шаг
    
    if (m < n) {
        /* 
         * РЕКУРСИВНЫЙ СЛУЧАЙ
         * 
         * Разделяем на четные и нечетные подпоследовательности
         * и рекурсивно сливаем их.
         */
        odd_even_merge(lo, n, m);      // Сливаем четные элементы
        odd_even_merge(lo + r, n, m);  // Сливаем нечетные элементы
        
        /* 
         * СОЗДАНИЕ ПАР ДЛЯ СРАВНЕНИЯ
         * 
         * После рекурсивного слияния нужно сравнить соседние элементы
         * из разных групп (четные и нечетные).
         */
        int max_pairs = n / m + 1;
        compare_arg_t* pairs = malloc(sizeof(compare_arg_t) * max_pairs);
        int pair_count = 0;
        
        /* Собираем пары элементов на расстоянии r друг от друга */
        for (int i = lo + r; i + r < lo + n; i += m) {
            pairs[pair_count].i = i;
            pairs[pair_count].j = i + r;
            pair_count++;
        }
        
        /* Выполняем все сравнения этого уровня ПАРАЛЛЕЛЬНО */
        compare_and_swap_level(pairs, pair_count);
        
        /* Освобождаем память */
        free(pairs);
        
    } else {
        /* 
         * БАЗОВЫЙ СЛУЧАЙ
         * 
         * Если m >= n, делаем одно сравнение.
         */
        if (lo + r < padded_n) {
            compare_arg_t pairs[1];
            pairs[0].i = lo;
            pairs[0].j = lo + r;
            compare_and_swap_level(pairs, 1);
        }
    }
}

/*
 * odd_even_merge_sort - СОРТИРОВКА по алгоритму Бэтчера
 * 
 * ЭТО ГЛАВНАЯ РЕКУРСИВНАЯ ФУНКЦИЯ!
 * 
 * ПРИНЦИП "РАЗДЕЛЯЙ И ВЛАСТВУЙ":
 *   1. Если массив из 1 элемента - уже отсортирован
 *   2. Иначе:
 *      a) Делим массив пополам
 *      b) Рекурсивно сортируем каждую половину
 *      c) Сливаем отсортированные половины через odd_even_merge
 * 
 * Параметры:
 *   @lo - начальный индекс сортируемого подмассива
 *   @n - размер подмассива
 * 
 * Пример:
 *   odd_even_merge_sort(0, 16);  // Сортируем весь массив размера 16
 */
void odd_even_merge_sort(int lo, int n) {
    /* БАЗОВЫЙ СЛУЧАЙ: массив из 0 или 1 элемента уже отсортирован */
    if (n <= 1) {
        return;
    }
    
    /* Находим середину */
    int m = n / 2;
    
    /* 
     * РЕКУРСИВНАЯ СОРТИРОВКА ПОЛОВИН
     * 
     * Сначала сортируем обе половины независимо.
     */
    odd_even_merge_sort(lo, m);          // Сортируем левую половину
    odd_even_merge_sort(lo + m, n - m);  // Сортируем правую половину
    
    /* 
     * СЛИЯНИЕ ОТСОРТИРОВАННЫХ ПОЛОВИН
     * 
     * Теперь обе половины отсортированы, осталось их слить.
     * Для этого используем специальное слияние Бэтчера!
     */
    odd_even_merge(lo, n, 1);
}

/*
 * batcher_sort - главная функция запуска сортировки
 * 
 * Просто запускает рекурсивную сортировку на всем массиве.
 */
void batcher_sort() {
    printf("\n=== Starting Batcher's Odd-Even Merge Sort ===\n");
    printf("Original size: %d, Padded to: %d, Max threads: %d\n\n", 
           n, padded_n, max_threads);
    
    /* Запускаем рекурсивную сортировку */
    odd_even_merge_sort(0, padded_n);
    
    printf("\n=== Sorting completed ===\n\n");
}

/*
 * ============================================================================
 * ГЛАВНАЯ ФУНКЦИЯ
 * ============================================================================
 */

int main(int argc, char* argv[]) {
    /*
     * ПРОВЕРКА АРГУМЕНТОВ КОМАНДНОЙ СТРОКИ
     * 
     * Формат: ./batcher_sort <max_threads> <число1> <число2> ...
     * Пример: ./batcher_sort 4 9 8 7 6 5 4 3 2 1
     */
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <max_threads> <num1> <num2> ...\n", argv[0]);
        fprintf(stderr, "Example: %s 4 9 8 7 6 5 4 3 2 1\n", argv[0]);
        return 1;
    }
    
    /* Парсим максимальное число потоков */
    max_threads = atoi(argv[1]);
    if (max_threads < 1) {
        fprintf(stderr, "Error: max_threads must be >= 1\n");
        return 1;
    }
    
    /* Парсим числа для сортировки */
    n = argc - 2;  // Количество чисел = аргументы минус имя программы и max_threads
    if (n < 2) {
        fprintf(stderr, "Error: need at least 2 numbers to sort\n");
        return 1;
    }
    
    /*
     * PADDING ДО СТЕПЕНИ ДВОЙКИ
     * 
     * Алгоритм Бэтчера работает для n = 2^k.
     * Если у нас 9 элементов, дополняем до 16.
     */
    padded_n = next_power_of_2(n);
    
    /* Выделяем память для дополненного массива */
    arr = malloc(sizeof(int) * padded_n);
    
    /* Заполняем реальные элементы из аргументов командной строки */
    for (int i = 0; i < n; i++) {
        arr[i] = atoi(argv[i + 2]);
    }
    
    /* 
     * ЗАПОЛНЕНИЕ SENTINEL-АМИ
     * 
     * Дополняем массив фиктивными элементами со значением INT_MAX.
     * Почему INT_MAX?
     *   Это максимальное значение int. Любое реальное число меньше его,
     *   поэтому sentinel-ы всегда "всплывут" в конец при сортировке.
     */
    for (int i = n; i < padded_n; i++) {
        arr[i] = INT_MAX;  // Фиктивный элемент (sentinel)
    }
    
    /*
     * ИНИЦИАЛИЗАЦИЯ СИНХРОНИЗАЦИИ
     * 
     * Семафор и мутекс нужно инициализировать перед использованием.
     */
    sem_init(&sem, 0, max_threads);      // Семафор со счетчиком = max_threads
    pthread_mutex_init(&print_mutex, NULL);  // Мутекс с настройками по умолчанию
    
    /* Вывод начального массива */
    printf("╔════════════════════════════════════════════════╗\n");
    printf("║   Batcher's Odd-Even Merge Sort (Parallel)    ║\n");
    printf("╚════════════════════════════════════════════════╝\n\n");
    print_array("Initial array: ");
    
    /* Измерение времени выполнения */
    long long start_time = get_time_ms();
    
    /* ЗАПУСК СОРТИРОВКИ */
    batcher_sort();
    
    long long end_time = get_time_ms();
    long long elapsed = end_time - start_time;
    
    /* Вывод результата (только реальные элементы!) */
    print_array("Sorted array:  ");
    
    /* Проверка корректности */
    if (is_sorted()) {
        printf("\n✓ Array is correctly sorted!\n");
    } else {
        printf("\n✗ ERROR: Array is NOT sorted!\n");
    }
    
    /* Статистика */
    printf("\nTime elapsed: %lld ms\n", elapsed);
    printf("Original elements: %d\n", n);
    printf("Padded to: %d (power of 2)\n", padded_n);
    printf("Max concurrent threads: %d\n", max_threads);
    
    /*
     * ОЧИСТКА РЕСУРСОВ
     * 
     * Важно! Нужно освободить семафор, мутекс и память.
     */
    sem_destroy(&sem);
    pthread_mutex_destroy(&print_mutex);
    free(arr);
    
    return 0;
}